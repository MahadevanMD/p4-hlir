#!/usr/bin/env python

# Copyright 2013-present Barefoot Networks, Inc. 
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import sys
from p4_hlir.main import HLIR
import p4_hlir.graphs.dot as dot
import json

def get_parser():
    parser = argparse.ArgumentParser(description='p4c-dot arguments')
    parser.add_argument('source', metavar='source', type=str,
                        help='a source file to include in the P4 program')
    parser.add_argument('--parser',
                        dest='graphs', action='append_const', const="parser",
                        help="generate parse graph")
    parser.add_argument('--table',
                        dest='graphs', action='append_const', const="table",
                        help="generate table control flow graph")
    parser.add_argument('--table-predecessors',
                        action='store_true',
                        help="include terminal parse states in table graph")
    parser.add_argument('--deps',
                        dest='graphs', action='append_const', const="deps",
                        help="generate table dependency graph")
    parser.add_argument('--gen-dir', dest='gen_dir', default = "",
                        help="destination directory for generate graphs")
    parser.add_argument('--dep-stages-with-conds',
                        action='store_true', default = False,
                        help='When counting stages and displaying allocation, \
                        do not include conditonal tables')
    parser.add_argument('--deps-no-control-flow-edges',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        do not include edges that are only there for
                        control flow purposes, e.g. because one table access
                        occurred in the source code sequentially before another,
                        but there is no field in the later table's search key
                        that depends upon an action of the earlier table.""")
    parser.add_argument('--deps-no-condition-labels',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        do not include the source code of the conditions
                        as part of the label on condition nodes.""")
    parser.add_argument('--deps-no-fields-on-edges',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        do not include the fields on dependency edges
                        indicating which ones the later table lookup
                        uses that may be modified by the earlier one.""")
    parser.add_argument('--deps-debug-count-min-stages',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        produce extra debugging output while counting
                        the minimum number of stages required to
                        execute the program.""")
    parser.add_argument('--debug-key-result-widths',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        produce extra debugging output showing how
                        the table search key and result widths were
                        calculated.""")
    parser.add_argument('--deps-skip-transitive-reduction',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        skip the step that minimizes the number of dependencies.
                        It uses an O(N^3) algorithm for doing so, if it is
                        not skipped, which can take a long time for larger
                        P4 programs.  It does significantly reduce the number
                        of dependencies, which can make the drawn dependency
                        graphs have no redundant dependencies.""")
    parser.add_argument('--primitives', action='append', default = [],
                        help="A JSON file which contains primitive declarations \
                        (to be used in addition to the standard ones)")

    return parser

def _get_p4_basename(p4_source):
    return os.path.splitext(os.path.basename(p4_source))[0]

def main():
    parser = get_parser()
    input_args = sys.argv[1:]
    args, unparsed_args = parser.parse_known_args()

    has_remaining_args = False
    preprocessor_args = []
    for a in unparsed_args:
        if a[:2] == "-D" or a[:2] == "-I":
            input_args.remove(a)
            preprocessor_args.append(a)
        else:
            has_remaining_args = True

    # trigger error
    if has_remaining_args:
        parser.parse_args(input_args)

    graphs_to_generate = args.graphs
    if not graphs_to_generate:
        graphs_to_generate = {"parser", "table", "deps"}
    else:
        graphs_to_generate = set(graphs_to_generate)

    if args.gen_dir:
        if not os.path.isdir(args.gen_dir):
            print args.gen_dir, "is not a valid directory"
            sys.exit(1)
    gen_dir = os.path.abspath(args.gen_dir)

    h = HLIR(args.source)
    for parg in preprocessor_args:
        h.add_preprocessor_args(parg)
    h.set_analysis_args({'do_transitive_reduction':
                         not args.deps_skip_transitive_reduction})

    for primitive_f in args.primitives:
        with open(primitive_f, 'r') as fp:
            h.add_primitives(json.load(fp))

    if not h.build():
        print "Error while building HLIR"
        sys.exit(1)

    print "Generating files in directory", gen_dir

    basename = _get_p4_basename(args.source)

    if "parser" in graphs_to_generate:
        dot.export_parse_graph(h, basename, gen_dir)
    if "table" in graphs_to_generate:
        dot.export_table_graph(h, basename, gen_dir, predecessors=args.table_predecessors)
    if "deps" in graphs_to_generate:
        dot.export_table_dependency_graph(
            h, basename, gen_dir,
            show_conds = args.dep_stages_with_conds,
            show_control_flow = not args.deps_no_control_flow_edges,
            show_condition_str = not args.deps_no_condition_labels,
            show_fields = not args.deps_no_fields_on_edges,
            debug_count_min_stages = args.deps_debug_count_min_stages,
            debug_key_result_widths = args.debug_key_result_widths)
    
    pass

if __name__ == "__main__":
    main()
