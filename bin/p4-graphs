#!/usr/bin/env python

# Copyright 2013-present Barefoot Networks, Inc.
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#    http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

import argparse
import os
import sys
from p4_hlir.main import HLIR
import p4_hlir.graphs.dot as dot
import json
import subprocess

def get_parser():
    parser = argparse.ArgumentParser(description='p4c-dot arguments')
    parser.add_argument('source', metavar='source', type=str,
                        help='a source file to include in the P4 program')
    parser.add_argument('--parser',
                        dest='graphs', action='append_const', const="parser",
                        help="generate parse graph")
    parser.add_argument('--table',
                        dest='graphs', action='append_const', const="table",
                        help="generate table control flow graph")
    parser.add_argument('--table-predecessors',
                        action='store_true',
                        help="include terminal parse states in table graph")
    parser.add_argument('--deps',
                        dest='graphs', action='append_const', const="deps",
                        help="generate table dependency graph")
    parser.add_argument('--gen-dir', dest='gen_dir', default = "",
                        help="destination directory for generate graphs")
    parser.add_argument('--dep-stages-with-conds',
                        action='store_true', default = False,
                        help='When counting stages and displaying allocation, \
                        do not include conditonal tables')
    parser.add_argument('--deps-no-control-flow-edges',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        do not include edges that are only there for
                        control flow purposes, e.g. because one table access
                        occurred in the source code sequentially before another,
                        but there is no field in the later table's search key
                        that depends upon an action of the earlier table.""")
    parser.add_argument('--deps-no-condition-labels',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        do not include the source code of the conditions
                        as part of the label on condition nodes.""")
    parser.add_argument('--deps-no-fields-on-edges',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        do not include the fields on dependency edges
                        indicating which ones the later table lookup
                        uses that may be modified by the earlier one.""")
    parser.add_argument('--deps-debug-count-min-stages',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        produce extra debugging output while counting
                        the minimum number of stages required to
                        execute the program.""")
    parser.add_argument('--debug-key-result-widths',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        produce extra debugging output showing how
                        the table search key and result widths were
                        calculated.""")
    parser.add_argument('--deps-skip-transitive-reduction',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs,
                        skip the step that minimizes the number of dependencies.
                        It uses an O(N^3) algorithm for doing so, if it is
                        not skipped, which can take a long time for larger
                        P4 programs.  It does significantly reduce the number
                        of dependencies, which can make the drawn dependency
                        graphs have no redundant dependencies.""")
    parser.add_argument('--split-match-action-events',
                        action='store_true', default = False,
                        help="""When drawing table dependency graphs and
                        calculating a shortest path, use separate 'events'
                        for a table's match and action portions.""")
    parser.add_argument('--dot-format', action='append', default = [],
                        help="""The format to use when running 'dot' for
                        generating visual graphs from .dot files.
                        Use 'none' to skip this step, which can be useful
                        for large P4 programs, and the dependency graphs
                        can get larger if --deps-skip-transitive-reduction
                        is specified.  The option can be given more than
                        once, in which case stop when 'none' is found,
                        or continue trying each format until the first
                        one is run that returns non-error exit status.""")
    parser.add_argument('--primitives', action='append', default = [],
                        help="A JSON file which contains primitive declarations \
                        (to be used in addition to the standard ones)")

    return parser

def check_for_dot():
    try:
        with open(os.devnull, 'w') as devnull:
            subprocess.check_call(["dot", "-?"], stdout=devnull)
        return True
    except:
        print "The 'dot' binary was not found.",
        print "This tool is distributed as part of the 'graphviz' package."
        print "If you are using a Debian system, try installing it with",
        print "'sudo apt-get install graphviz'."
        return False

def _get_p4_basename(p4_source):
    return os.path.splitext(os.path.basename(p4_source))[0]

def main():
    parser = get_parser()
    input_args = sys.argv[1:]
    args, unparsed_args = parser.parse_known_args()

    has_remaining_args = False
    preprocessor_args = []
    for a in unparsed_args:
        if a[:2] == "-D" or a[:2] == "-I":
            input_args.remove(a)
            preprocessor_args.append(a)
        else:
            has_remaining_args = True

    # trigger error
    if has_remaining_args:
        parser.parse_args(input_args)

    graphs_to_generate = args.graphs
    if not graphs_to_generate:
        graphs_to_generate = {"parser", "table", "deps"}
    else:
        graphs_to_generate = set(graphs_to_generate)

    if args.gen_dir:
        if not os.path.isdir(args.gen_dir):
            print args.gen_dir, "is not a valid directory"
            sys.exit(1)
    gen_dir = os.path.abspath(args.gen_dir)

    if (args.split_match_action_events and
        not args.deps_skip_transitive_reduction):
        print("If you specify --split-match-action-events,"
              " must also specify --deps-skip-transitive-reduction,"
              " or else it can give incorrect scheduling results")
        sys.exit(1)

    h = HLIR(args.source)
    for parg in preprocessor_args:
        h.add_preprocessor_args(parg)
    h.set_analysis_args({'do_transitive_reduction':
                         not args.deps_skip_transitive_reduction})

    for primitive_f in args.primitives:
        with open(primitive_f, 'r') as fp:
            h.add_primitives(json.load(fp))

    if not h.build():
        print "Error while building HLIR"
        sys.exit(1)

    if not check_for_dot():
        sys.exit(1)

    print "Generating files in directory", gen_dir

    basename = _get_p4_basename(args.source)

    dot_formats = args.dot_format
    if len(dot_formats) == 0:
        dot_formats = ['png', 'eps']
    if "parser" in graphs_to_generate:
        dot.export_parse_graph(h, basename, gen_dir,
                               dot_formats = dot_formats)
    if "table" in graphs_to_generate:
        dot.export_table_graph(h, basename, gen_dir,
                               predecessors=args.table_predecessors,
                               dot_formats = dot_formats)
    if "deps" in graphs_to_generate:
        dot.export_table_dependency_graph(
            h, basename, gen_dir,
            show_conds = args.dep_stages_with_conds,
            show_control_flow = not args.deps_no_control_flow_edges,
            show_condition_str = not args.deps_no_condition_labels,
            show_fields = not args.deps_no_fields_on_edges,
            debug_count_min_stages = args.deps_debug_count_min_stages,
            debug_key_result_widths = args.debug_key_result_widths,
            dot_formats = dot_formats,
            split_match_action_events = args.split_match_action_events)
    
    pass

if __name__ == "__main__":
    main()
